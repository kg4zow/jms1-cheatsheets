---
syntax  : bash
---
###############################################################################
#
# Shell functions to emit coloured lines

############################################################
# Slice and dice a message into lines, print each line in the selected colour
# - First parameter is the "n;n;n" value representing the foreground/background
#   colour. It will be inserted into an "ESC [ ___ m" sequence.
# - If more parmeters are present, they will be processsed.
#   - Each parameter may be a single-line, multi-line, or empty string.
# - If no more parameters are present, STDIN will be split into lines
#   - empty lines in input will become blank coloured lines
#   - empty STDIN will generate no output

function coloured_line {
    local COL P IFS LINE LINES

    ########################################
    # The first parameter (required) is the 'n;n;n' code used in the escape
    # sequence to set up the foreground and/or background colours.
    #   ESC [ ___ m

    COL="${1:?no colour code specified}"
    shift

    ########################################
    # If any parameters remain (after shifting off the colour code),
    # process each parameter.
    # - Each parameter may be a single-line, multi-line, or empty string.
    # - Split each parameter's value into lines.
    # - Print each line, with the appropriate colour codes before/after it.

    if (( $# > 0 ))
    then
        for P in "$@"
        do
            if [[ -n "$P" ]]
            then
                while IFS='' read -r LINE
                do
                    printf "\e[%sm%s\e[0K\e[0m\n" "$COL" "$LINE"
                done <<< "$P"
            else
                printf "\e[%sm%s\e[0K\e[0m\n" "$COL" ''
            fi
        done

    ########################################
    # Otherwise (if no more parameters exist), process STDIN.
    # - Each line will be printed, with the appropriate colour codes.
    # - Empty lines are printed as empty strings, in the appropriate colour.

    else
        while IFS='' read -r LINE
        do
            printf "\e[%sm%s\e[0K\e[0m\n" "$COL" "$LINE"
        done
    fi
}

############################################################
# Wrappers which specify different colours

function redline {
    coloured_line '0;1;37;41' "$@"
}

function yellowline {
    coloured_line '0;30;43' "$@"
}

function blueline {
    coloured_line '0;1;37;44' "$@"
}

function greenline {
    coloured_line '0;1;37;42' "$@"
}

function cyanline {
    coloured_line '0;1;37;46' "$@"
}

function purpleline {
    coloured_line '0;1;37;45' "$@"
}

function whiteline {
    coloured_line '0;1;37;47' "$@"
}

function fail {
    redline "$@"
    exit 1
}
