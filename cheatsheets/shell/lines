---
syntax  : bash
---
###############################################################################
#
# Shell functions to emit coloured lines

############################################################
# Slice and dice a message into lines, print each line in the selected colour
# - first parameter is colour, will be inserted into "ESC [ ... m" sequence
# - if more parmeters are present, each is a line (or multi-line)
# - if no more parameters are present, STDIN will be split into lines

function coloured_line {
    local COL P IFS LINE LINES

    COL="${1:?no colour code specified}"
    shift

    if [[ -n "$1" ]]
    then
        ########################################
        # each parameter is a line

        for P in "$@"
        do
            IFS=$'\n' read -a LINES -d '' -r <<< "$P" || true
            for LINE in "${LINES[@]}"
            do
                printf "\e[%sm%s\e[0K\e[0m\n" "$COL" "$LINE"
            done
        done
    else
        ########################################
        # STDIN will contain one or more lines of text

        while IFS='' read -r LINE
        do
            printf "\e[%sm%s\e[0K\e[0m\n" "$COL" "$LINE"
        done
    fi
}

function redline {
    coloured_line '0;1;37;41' "$@"
}

function yellowline {
    coloured_line '0;30;43' "$@"
}

function blueline {
    coloured_line '0;1;37;44' "$@"
}

function greenline {
    coloured_line '0;1;37;42' "$@"
}

function cyanline {
    coloured_line '0;1;37;46' "$@"
}

function purpleline {
    coloured_line '0;1;37;45' "$@"
}

function whiteline {
    coloured_line '0;1;37;47' "$@"
}

function fail {
    redline "$@"
    exit 1
}
