#!/bin/bash
#
# script-name
# Author <email@example.com> 2020-02-02
readonly LAST_UPDATED="2026-02-22"
#
# Quick description of what the script does.
#
###############################################################################
#
# Portions of the script are from a template created by John Simpson, who has
# released them under the MIT License.
#
# MIT License
#
# Copyright (C) 2025-2026 John Simpson
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
###############################################################################
#
# The remaining contents of the script are covered under this license:
#
# (License Name)
#
# Copyright (C) 2026 whoever
#
# Details about this script's licensing
#
###############################################################################

set -e

PATH="/usr/bin:/bin"

########################################
# Global variables
#   MYDIR   dir containing script   '/Users/jms1/bin'
#   MYNAME  name of script          'xyzzy'
#   MYSELF  full path to script     '/Users/jms1/bin/xyzzy'

MYDIR="$( cd -- "$( dirname -- "$0" )" >/dev/null 2>&1 || exit 1 ; pwd -P )"
MYNAME="$( basename -- "$0" )"
MYSELF="$MYDIR/$MYNAME"

########################################
# Directories used by the script itself
# XDG: https://specifications.freedesktop.org/basedir-spec/latest/

CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/${MYNAME}"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/${MYNAME}"
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/${MYNAME}"
STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/${MYNAME}"

CONFIG_FILE="${CONFIG_DIR}/${MYNAME}.conf"

# dummy entries to make shellcheck not complain about un-used variables
echo "CACHE_DIR='$CACHE_DIR'" > /dev/null
echo "CONFIG_DIR='$CONFIG_DIR'" > /dev/null
echo "DATA_DIR='$DATA_DIR'" > /dev/null
echo "STATE_DIR='$STATE_DIR'" > /dev/null

###############################################################################
#
# Coloured line functions

############################################################
# Slice and dice a message into lines, print each line in the selected colour
# - First parameter is the "n;n;n" value representing the foreground/background
#   colour. It will be inserted into an "ESC [ ___ m" sequence.
# - If more parmeters are present, they will be processsed.
#   - Each parameter may be a single-line, multi-line, or empty string.
# - If no more parameters are present, STDIN will be split into lines
#   - empty lines in input will become blank coloured lines
#   - empty STDIN will generate no output

function coloured_line {
    local COL P IFS LINE LINES

    ########################################
    # The first parameter (required) is the 'n;n;n' code used in the escape
    # sequence to set up the foreground and/or background colours.
    #   ESC [ ___ m

    COL="${1:?no colour code specified}"
    shift

    ########################################
    # If any parameters remain (after shifting off the colour code),
    # process each parameter.
    # - Each parameter may be a single-line, multi-line, or empty string.
    # - Split each parameter's value into lines.
    # - Print each line, with the appropriate colour codes before/after it.

    if (( $# > 0 ))
    then
        for P in "$@"
        do
            if [[ -n "$P" ]]
            then
                while IFS='' read -r LINE
                do
                    printf "\e[%sm%s\e[0K\e[0m\n" "$COL" "$LINE"
                done <<< "$P"
            else
                printf "\e[%sm%s\e[0K\e[0m\n" "$COL" ''
            fi
        done

    ########################################
    # Otherwise (if no more parameters exist), process STDIN.
    # - Each line will be printed, with the appropriate colour codes.
    # - Empty lines are printed as empty strings, in the appropriate colour.

    else
        while IFS='' read -r LINE
        do
            printf "\e[%sm%s\e[0K\e[0m\n" "$COL" "$LINE"
        done
    fi
}

############################################################
# Wrappers which specify different colours

function redline {
    coloured_line '0;1;37;41' "$@"
}

function yellowline {
    coloured_line '0;30;43' "$@"
}

function blueline {
    coloured_line '0;1;37;44' "$@"
}

function greenline {
    coloured_line '0;1;37;42' "$@"
}

function cyanline {
    coloured_line '0;1;37;46' "$@"
}

function purpleline {
    coloured_line '0;1;37;45' "$@"
}

function whiteline {
    coloured_line '0;1;37;47' "$@"
}

function fail {
    redline "$@"
    exit 1
}

###############################################################################
#
# Maybe print a command before executing it

SET_X="${SET_X:-false}"

function set_x {
    local IFS=' '
    if [[ "${SET_X:-false}" == "true" ]]
    then
        cyanline "$PS4$*" 1>&2
    fi
    "$@"
}

########################################
# Show the same output that set_x would show,
# but don't actually run the command

function show_x {
    local IFS=' '
    if [[ "${SET_X:-false}" == "true" ]]
    then
        cyanline "$PS4$*" 1>&2
    fi
}

###############################################################################
#
# Debugging message

DO_DEBUG="${DO_DEBUG:-false}"
DEBUG_PREFIX=$'\f'

function debug {
    local IFS LINE LINES PREFIX

    if [[ "${DO_DEBUG:-false}" == "true" ]]
    then
        if [[ "$DEBUG_PREFIX" == $'\f' ]]
        then
            local CALLER C_LINE C_FILE
            CALLER="$( caller )"
            C_LINE="${CALLER% *}"
            C_FILE="${CALLER#* }"
            PREFIX="$C_FILE:$C_LINE: "
        else
            PREFIX="$DEBUG_PREFIX"
        fi

        IFS=$'\n' read -a LINES -d '' -r <<< "$*" || true
        for LINE in "${LINES[@]}"
        do
            yellowline "$PREFIX$LINE" 1>&2
        done
    fi
}

###############################################################################
#
# Usage
# - https://docopt.org/ is the "standard" for how to describe options

function usage {
    local MSG="${*:-}"

    cat <<EOF
$0 [OPTIONS] [ARGS]

Detailed description of what the script does.

-b      Enable BVAR

-s ___  Specify SVAR

-x      Show the important commands before executing them.

-D      Show debugging messages. Also enables '-x'.

-h      Show this help message.

Note: two arguments are required in order to do anything.

Last updated $LAST_UPDATED

EOF

    if [[ -n "$MSG" ]]
    then
        fail "$MSG"
    fi

    exit 0
}

###############################################################################
###############################################################################
###############################################################################
#
# Process the command line

BVAR=false
SVAR="(default)"

while getopts ':hbs:xD' OPT
do
    case $OPT in
        h)  usage
            ;;
        b)  BVAR=true
            ;;
        s)  SVAR="$OPTARG"
            ;;
        x)  SET_X=true
            ;;
        D)  DO_DEBUG=true
            SET_X=true
            ;;
        *)  usage "ERROR: unknown option '-${OPTARG}'"
            ;;
    esac
done

shift $(( OPTIND - 1 ))

ARG1="${1:-}"
ARG2="${2:-}"

if [[ -z "$ARG1" ]]
then
    usage
fi

if [[ -z "$ARG2" ]]
then
    usage "ERROR: missing ARG2"
fi

###############################################################################
#
# Do the things

echo "MYDIR='${MYDIR}'"
echo "MYNAME='${MYNAME}'"
echo "MYSELF='${MYSELF}'"
echo "CONFIG_DIR='${CONFIG_DIR}'"
echo "CONFIG_FILE='${CONFIG_FILE}'"
echo "BVAR='${BVAR}'"
echo "SVAR='${SVAR}'"
echo "ARG1='${ARG1}'"
echo "ARG2='${ARG2}'"
